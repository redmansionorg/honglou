import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

const AUTHOR_REGISTRY_ABI = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_author",
                "type": "address"
            }
        ],
        "name": "getAuthorInfo",
        "outputs": [
            {
                "components": [
                    {
                        "internalType": "address",
                        "name": "author",
                        "type": "address"
                    },
                    {
                        "internalType": "string",
                        "name": "name",
                        "type": "string"
                    },
                    {
                        "internalType": "bytes32",
                        "name": "identityHash",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "string",
                        "name": "email",
                        "type": "string"
                    },
                    {
                        "internalType": "bytes32",
                        "name": "verifyHash",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "string",
                        "name": "metadataCid",
                        "type": "string"
                    },
                    {
                        "internalType": "uint256",
                        "name": "createTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "updateTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "isCelebrity",
                        "type": "bool"
                    },
                    {
                        "internalType": "bool",
                        "name": "isKYC",
                        "type": "bool"
                    },
                    {
                        "internalType": "bool",
                        "name": "isVerified",
                        "type": "bool"
                    },
                    {
                        "internalType": "bool",
                        "name": "active",
                        "type": "bool"
                    }
                ],
                "internalType": "struct IAuthorRegistry.AuthorInfo",
                "name": "",
                "type": "tuple"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
];

const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function downloadTextFromIPFS(ipfsUrl, timeoutMs = 5000) {
    try {
        console.log(`下载文本内容: ${ipfsUrl}`);
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
        
        const response = await fetch(ipfsUrl, { 
            signal: controller.signal,
            headers: {
                'Accept': 'text/plain,text/*,*/*',
                'User-Agent': 'Mozilla/5.0 (compatible; NovelApp/1.0)'
            }
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const text = await response.text();
        return text.trim();
    } catch (error) {
        console.error(`文本下载失败 ${ipfsUrl}:`, error.message);
        return null;
    }
}

async function downloadJsonFromIPFS(ipfsUrl, timeoutMs = 5000) {
    try {
        console.log(`下载JSON元数据: ${ipfsUrl}`);
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
        
        const response = await fetch(ipfsUrl, { 
            signal: controller.signal,
            headers: {
                'Accept': 'application/json,text/*,*/*',
                'User-Agent': 'Mozilla/5.0 (compatible; NovelApp/1.0)'
            }
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const jsonText = await response.text();
        return JSON.parse(jsonText);
    } catch (error) {
        console.error(`JSON下载失败 ${ipfsUrl}:`, error.message);
        return null;
    }
}

function processImageUrl(ipfsUrl) {
    return ipfsUrl;
}

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);
        const user = await base44.auth.me();
        if (!user) {
            return Response.json({ error: 'Unauthorized' }, { status: 401 });
        }

        const { ethers } = await import('npm:ethers@6.7.1');
        
        const rpcUrl = Deno.env.get("SEPOLIA_RPC_URL");
        let ipfsGateway = Deno.env.get("IPFS_GATEWAY_URL") || "";
        const authorRegistryAddress = Deno.env.get("AUTHOR_REGISTRY_CONTRACT_ADDRESS");

        if (ipfsGateway) {
            ipfsGateway = ipfsGateway.replace(/\/ipfs\/?$/, "").replace(/\/$/, "");
        }

        if (!rpcUrl || !ipfsGateway || !authorRegistryAddress) {
            throw new Error("缺少必要的环境变量");
        }

        const provider = new ethers.JsonRpcProvider(rpcUrl);
        const authorRegistry = new ethers.Contract(authorRegistryAddress, AUTHOR_REGISTRY_ABI, provider);

        // 获取所有小说以找到唯一的作者地址
        const novels = await base44.entities.Novel.list();
        const uniqueAuthorAddresses = [...new Set(novels
            .filter(n => n.bc_author_address)
            .map(n => n.bc_author_address.toLowerCase())
        )];

        console.log(`[SyncAuthorProfiles] Processing ${uniqueAuthorAddresses.length} unique authors`);

        const stats = {
            processed: 0,
            created: 0,
            updated: 0,
            errors: 0
        };

        for (const authorAddress of uniqueAuthorAddresses) {
            try {
                await delay(500);
                
                console.log(`处理作者地址: ${authorAddress}`);
                const authorInfo = await authorRegistry.getAuthorInfo(authorAddress);
                
                if (!authorInfo.name || !authorInfo.active) {
                    console.log(`跳过作者 ${authorAddress}: 名称为空或未激活`);
                    continue;
                }

                const authorData = {
                    bc_address: authorAddress,
                    pseudonym: authorInfo.name,
                    email: authorInfo.email || "",
                    bc_metadata_cid: authorInfo.metadataCid || "",
                    create_time: parseInt(authorInfo.createTime.toString()),
                    update_time: parseInt(authorInfo.updateTime.toString()),
                    is_celebrity: authorInfo.isCelebrity,
                    is_kyc: authorInfo.isKYC,
                    is_verified: authorInfo.isVerified,
                    is_active: authorInfo.active,
                    bio: "加载中...",
                    avatar_url: "",
                    cover_url: "",
                    external_url: ""
                };

                // 如果有元数据CID，下载并解析
                if (authorInfo.metadataCid) {
                    const metadataUrl = `${ipfsGateway}/ipfs/${authorInfo.metadataCid}`;
                    const metadata = await downloadJsonFromIPFS(metadataUrl, 3000);
                    
                    if (metadata) {
                        authorData.external_url = metadata.external_url || "";
                        authorData.bc_bio_cid = metadata.bioCid || "";
                        authorData.bc_avatar_cid = metadata.avatarCid || "";
                        authorData.bc_cover_cid = metadata.coverCid || "";

                        // 下载简介文本
                        if (metadata.bioCid) {
                            const bioText = await downloadTextFromIPFS(`${ipfsGateway}/ipfs/${metadata.bioCid}`, 3000);
                            if (bioText) {
                                authorData.bio = bioText;
                            }
                        }

                        // 生成图片URL
                        if (metadata.avatarCid) {
                            authorData.avatar_url = processImageUrl(`${ipfsGateway}/ipfs/${metadata.avatarCid}`);
                        }
                        
                        if (metadata.coverCid) {
                            authorData.cover_url = processImageUrl(`${ipfsGateway}/ipfs/${metadata.coverCid}`);
                        }
                    }
                }

                // 检查是否已存在
                const existing = await base44.entities.AuthorProfile.filter({ bc_address: authorAddress });
                
                if (existing.length > 0) {
                    await base44.entities.AuthorProfile.update(existing[0].id, authorData);
                    stats.updated++;
                } else {
                    await base44.entities.AuthorProfile.create(authorData);
                    stats.created++;
                }
                
                stats.processed++;
            } catch (error) {
                console.error(`处理作者 ${authorAddress} 时出错:`, error.message);
                stats.errors++;
            }
        }
        
        return Response.json({ 
            success: true,
            summary: `处理完成。新增: ${stats.created}, 更新: ${stats.updated}, 错误: ${stats.errors}`
        });

    } catch (error) {
        console.error('同步作者信息过程发生错误:', error);
        return Response.json({ 
            error: error.message, 
            details: "同步作者信息过程中发生错误，请查看日志"
        }, { status: 500 });
    }
});